export function useIngest() {
  const supabase = useSupabaseClient()
  const API_BASE =
    useRuntimeConfig().public.apiBase ?? 'http://127.0.0.1:8000/api/v1'

  async function token() {
    const { data } = await supabase.auth.getSession()
    return data.session?.access_token
  }

  async function authHeaders() {
    const t = await token()
    if (!t) throw new Error('Not logged in')
    return { Authorization: `Bearer ${t}` }
  }

  // --- Upload ---

  async function uploadFile(file: File, groupId?: string, enableTagging: boolean = true) {
    try {
      const headers = await authHeaders()
      const fd = new FormData()
      fd.append('file', file)
      if (groupId) fd.append('group_id', groupId)
      fd.append('enable_tagging', enableTagging.toString())

      await $fetch(`${API_BASE}/ingest/upload-text-and-images`, {
        method: 'POST',
        headers,
        body: fd,
      })
    } catch (err: any) {
      throw new Error(err?.data || err?.message || 'Upload failed')
    }
  }

  // ---- Types for queries ----
  type BaseQueryOpts = { top_k?: number; group_id?: string }
  type TextQueryOpts = BaseQueryOpts & {
    query: string
    route: 'text' | 'image' | 'extracted_image' // UPDATED
    search_mode?: 'smart' | 'keyword' // NEW: search mode for text queries
  }
  type ImageQueryOpts = BaseQueryOpts & { file: File }

  interface Match {
    id: string
    score: number
    metadata: {
      text?: string
      source?: string // 'extracted' for deep embeds
      parent_filename?: string // parent document name
      parent_storage_path?: string // parent document storage path
      parent_bucket?: string // parent document bucket
      page_number?: number // page number
      bucket?: string // storage bucket (used with storage_path to generate signed URLs)
      storage_path?: string // storage path (used with bucket to generate signed URLs)
      signed_url?: string // signed URL (generated by frontend via /storage/signed-url endpoint)
      dimensions?: string // image dimensions
      [key: string]: any
    }
  }

  interface QueryResponse {
    matches: Match[]
    top_k: number
    route: string
    namespace: string
  }

  // --- Query (text input) ---
  async function queryText(opts: TextQueryOpts): Promise<QueryResponse> {
    try {
      const headers = {
        'Content-Type': 'application/json',
        ...(await authHeaders()),
      }

      return await $fetch<QueryResponse>(`${API_BASE}/ingest/query`, {
        method: 'POST',
        headers,
        body: {
          query_text: opts.query,
          route: opts.route,
          top_k: opts.top_k ?? 10,
          group_id: opts.group_id ?? undefined,
          search_mode: opts.search_mode ?? 'smart', // Default to smart search
        },
      })
    } catch (err: any) {
      throw new Error(err?.data || err?.message || 'Text query failed')
    }
  }

  // --- Query (image input) ---
  async function queryImage(opts: ImageQueryOpts): Promise<QueryResponse> {
    try {
      const headers = {
        'Content-Type': 'application/json',
        ...(await authHeaders()),
      }
      const buf = await opts.file.arrayBuffer()
      const b64 = btoa(String.fromCharCode(...new Uint8Array(buf)))

      return await $fetch<QueryResponse>(`${API_BASE}/ingest/query`, {
        method: 'POST',
        headers,
        body: {
          image_b64: b64,
          top_k: opts.top_k ?? 10,
          group_id: opts.group_id ?? undefined,
        },
      })
    } catch (err: any) {
      throw new Error(err?.data || err?.message || 'Image query failed')
    }
  }

  // --- Delete document ---
  async function deleteDoc(doc_id: string) {
    try {
      const headers = await authHeaders()
      const url = `${API_BASE}/ingest/delete-document?doc_id=${encodeURIComponent(
        doc_id
      )}`
      await $fetch(url, { method: 'DELETE', headers })
    } catch (err: any) {
      throw new Error(err?.data || err?.message || 'Delete failed')
    }
  }

  // --- Query by tags ---
  interface TagQueryOpts {
    tags: string[]
    min_confidence?: number
    limit?: number
    category?: string
    group_id?: string
  }

  interface TagQueryResponse {
    results: any[]
    count: number
  }

  async function queryByTags(opts: TagQueryOpts): Promise<TagQueryResponse> {
    try {
      const headers = {
        'Content-Type': 'application/json',
        ...(await authHeaders()),
      }

      const params = new URLSearchParams()
      if (opts.category) params.append('category', opts.category)
      if (opts.group_id !== undefined) params.append('group_id', opts.group_id)

      const queryString = params.toString() ? `?${params.toString()}` : ''

      return await $fetch<TagQueryResponse>(
        `${API_BASE}/tagging/search/by-document-tags${queryString}`,
        {
          method: 'POST',
          headers,
          body: {
            tags: opts.tags,
            min_confidence: opts.min_confidence ?? 0.5,
            limit: opts.limit ?? 50,
          },
        }
      )
    } catch (err: any) {
      throw new Error(err?.data || err?.message || 'Tag query failed')
    }
  }

  // --- Query images by tags ---
  async function queryImagesByTags(opts: TagQueryOpts): Promise<TagQueryResponse> {
    try {
      const headers = {
        'Content-Type': 'application/json',
        ...(await authHeaders()),
      }

      const params = new URLSearchParams()
      if (opts.group_id !== undefined) params.append('group_id', opts.group_id)

      const queryString = params.toString() ? `?${params.toString()}` : ''

      return await $fetch<TagQueryResponse>(
        `${API_BASE}/tagging/search/by-tags${queryString}`,
        {
          method: 'POST',
          headers,
          body: {
            tags: opts.tags,
            min_confidence: opts.min_confidence ?? 0.7,
            limit: opts.limit ?? 50,
          },
        }
      )
    } catch (err: any) {
      throw new Error(err?.data || err?.message || 'Image tag query failed')
    }
  }

  // --- Get available tags ---
  interface TagCategory {
    label: string
    description: string
    tags: string[]
  }

  interface AvailableTagsResponse {
    categories: Record<string, TagCategory>
  }

  async function getAvailableTags(): Promise<AvailableTagsResponse> {
    try {
      const headers = await authHeaders()
      return await $fetch<AvailableTagsResponse>(
        `${API_BASE}/tagging/tags/available`,
        {
          method: 'GET',
          headers,
        }
      )
    } catch (err: any) {
      throw new Error(err?.data || err?.message || 'Failed to fetch tags')
    }
  }

  // --- Get user's actual tags ---
  interface UserTagsResponse {
    categories: Record<string, string[]>
    total_unique_tags: number
  }

  async function getUserTags(tagType: 'document' | 'image' = 'document'): Promise<UserTagsResponse> {
    try {
      const headers = await authHeaders()
      return await $fetch<UserTagsResponse>(
        `${API_BASE}/tagging/tags/user-tags?tag_type=${tagType}`,
        {
          method: 'GET',
          headers,
        }
      )
    } catch (err: any) {
      throw new Error(err?.data || err?.message || 'Failed to fetch user tags')
    }
  }

  return {
    uploadFile,
    queryText,
    queryImage,
    deleteDoc,
    queryByTags,
    queryImagesByTags,
    getAvailableTags,
    getUserTags,
  }
}