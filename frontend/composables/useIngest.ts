export function useIngest() {
  const supabase = useSupabaseClient()
  const API_BASE =
    useRuntimeConfig().public.apiBase ?? 'http://127.0.0.1:8000/api/v1'

  async function token() {
    const { data } = await supabase.auth.getSession()
    return data.session?.access_token
  }

  async function authHeaders() {
    const t = await token()
    if (!t) throw new Error('Not logged in')
    return { Authorization: `Bearer ${t}` }
  }

  // --- Upload ---

  interface UploadResponse {
    doc_id: string
    status: 'queued' | 'processing' | 'completed' | 'failed'
    message: string
    filename: string
    storage_path: string
  }

  async function uploadFile(file: File, groupId?: string, enableTagging: boolean = true): Promise<UploadResponse> {
    try {
      const headers = await authHeaders()
      const fd = new FormData()
      fd.append('file', file)
      if (groupId) fd.append('group_id', groupId)
      fd.append('enable_tagging', enableTagging.toString())

      const response = await $fetch<UploadResponse>(`${API_BASE}/ingest/upload-text-and-images`, {
        method: 'POST',
        headers,
        body: fd,
      })

      return response
    } catch (err: any) {
      throw new Error(err?.data || err?.message || 'Upload failed')
    }
  }

  // --- Get processing status ---

  interface ProcessingStatus {
    doc_id: string
    status: 'queued' | 'processing' | 'completed' | 'failed'
    filename: string | null
    text_chunks_count: number
    images_count: number
    error_message: string | null
    modality?: string
    long_running?: boolean
    processing_time_seconds?: number | null
  }

  async function getProcessingStatus(docId: string): Promise<ProcessingStatus> {
    try {
      const headers = await authHeaders()
      return await $fetch<ProcessingStatus>(`${API_BASE}/ingest/processing-status/${docId}`, {
        method: 'GET',
        headers,
      })
    } catch (err: any) {
      throw new Error(err?.data || err?.message || 'Failed to get processing status')
    }
  }

  // --- Poll processing status until complete ---

  async function pollProcessingStatus(
    docId: string,
    onUpdate?: (status: ProcessingStatus) => void,
    maxAttempts: number = 60,
    intervalMs: number = 2000
  ): Promise<ProcessingStatus> {
    let currentIntervalMs = intervalMs

    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      const status = await getProcessingStatus(docId)

      if (onUpdate) {
        onUpdate(status)
      }

      if (status.status === 'completed' || status.status === 'failed') {
        return status
      }

      // For videos or long-running tasks, switch to slower polling (30 seconds)
      if (status.long_running || status.modality === 'video') {
        currentIntervalMs = 30000 // 30 seconds for videos/long-running tasks
      }

      // Wait before next poll
      await new Promise(resolve => setTimeout(resolve, currentIntervalMs))
    }

    throw new Error('Processing timeout: file took too long to process')
  }

  // ---- Types for queries ----
  type BaseQueryOpts = { top_k?: number; group_id?: string }
  type TextQueryOpts = BaseQueryOpts & {
    query: string
    route: 'text' | 'image' | 'extracted_image' | 'video_frames' | 'video_transcript' | 'video_combined' // UPDATED: added video routes
    search_mode?: 'smart' | 'keyword' // NEW: search mode for text queries
  }
  type ImageQueryOpts = BaseQueryOpts & { file: File }
  type VideoQueryOpts = BaseQueryOpts & {
    query: string
    route: 'video_frames' | 'video_transcript' | 'video_combined'
  }

  interface Match {
    id: string
    score: number
    metadata: {
      text?: string
      source?: string // 'extracted' for deep embeds
      parent_filename?: string // parent document name
      parent_storage_path?: string // parent document storage path
      parent_bucket?: string // parent document bucket
      page_number?: number // page number
      bucket?: string // storage bucket (used with storage_path to generate signed URLs)
      storage_path?: string // storage path (used with bucket to generate signed URLs)
      signed_url?: string // signed URL (generated by frontend via /storage/signed-url endpoint)
      dimensions?: string // image dimensions
      [key: string]: any
    }
  }

  interface QueryResponse {
    matches: Match[]
    top_k: number
    route: string
    namespace: string
  }

  // --- Query (text input) ---
  async function queryText(opts: TextQueryOpts): Promise<QueryResponse> {
    try {
      const headers = {
        'Content-Type': 'application/json',
        ...(await authHeaders()),
      }

      return await $fetch<QueryResponse>(`${API_BASE}/ingest/query`, {
        method: 'POST',
        headers,
        body: {
          query_text: opts.query,
          route: opts.route,
          top_k: opts.top_k ?? 10,
          group_id: opts.group_id ?? undefined,
          search_mode: opts.search_mode ?? 'smart', // Default to smart search
        },
      })
    } catch (err: any) {
      throw new Error(err?.data || err?.message || 'Text query failed')
    }
  }

  // --- Query (image input) ---
  async function queryImage(opts: ImageQueryOpts): Promise<QueryResponse> {
    try {
      const headers = {
        'Content-Type': 'application/json',
        ...(await authHeaders()),
      }
      const buf = await opts.file.arrayBuffer()
      const b64 = btoa(String.fromCharCode(...new Uint8Array(buf)))

      return await $fetch<QueryResponse>(`${API_BASE}/ingest/query`, {
        method: 'POST',
        headers,
        body: {
          image_b64: b64,
          top_k: opts.top_k ?? 10,
          group_id: opts.group_id ?? undefined,
        },
      })
    } catch (err: any) {
      throw new Error(err?.data || err?.message || 'Image query failed')
    }
  }

  // --- Delete document ---
  async function deleteDoc(doc_id: string) {
    try {
      const headers = await authHeaders()
      const url = `${API_BASE}/ingest/delete-document?doc_id=${encodeURIComponent(
        doc_id
      )}`
      await $fetch(url, { method: 'DELETE', headers })
    } catch (err: any) {
      throw new Error(err?.data || err?.message || 'Delete failed')
    }
  }

  // --- Query by tags ---
  interface TagQueryOpts {
    tags: string[]
    min_confidence?: number
    limit?: number
    category?: string
    group_id?: string
  }

  interface TagQueryResponse {
    results: any[]
    count: number
  }

  async function queryByTags(opts: TagQueryOpts): Promise<TagQueryResponse> {
    try {
      const headers = {
        'Content-Type': 'application/json',
        ...(await authHeaders()),
      }

      const params = new URLSearchParams()
      if (opts.category) params.append('category', opts.category)
      if (opts.group_id !== undefined) params.append('group_id', opts.group_id)

      const queryString = params.toString() ? `?${params.toString()}` : ''

      return await $fetch<TagQueryResponse>(
        `${API_BASE}/tagging/search/by-document-tags${queryString}`,
        {
          method: 'POST',
          headers,
          body: {
            tags: opts.tags,
            min_confidence: opts.min_confidence ?? 0.5,
            limit: opts.limit ?? 50,
          },
        }
      )
    } catch (err: any) {
      throw new Error(err?.data || err?.message || 'Tag query failed')
    }
  }

  // --- Query images by tags ---
  async function queryImagesByTags(opts: TagQueryOpts): Promise<TagQueryResponse> {
    try {
      const headers = {
        'Content-Type': 'application/json',
        ...(await authHeaders()),
      }

      const params = new URLSearchParams()
      if (opts.group_id !== undefined) params.append('group_id', opts.group_id)

      const queryString = params.toString() ? `?${params.toString()}` : ''

      return await $fetch<TagQueryResponse>(
        `${API_BASE}/tagging/search/by-tags${queryString}`,
        {
          method: 'POST',
          headers,
          body: {
            tags: opts.tags,
            min_confidence: opts.min_confidence ?? 0.7,
            limit: opts.limit ?? 50,
          },
        }
      )
    } catch (err: any) {
      throw new Error(err?.data || err?.message || 'Image tag query failed')
    }
  }

  // --- Get available tags ---
  interface TagCategory {
    label: string
    description: string
    tags: string[]
  }

  interface AvailableTagsResponse {
    categories: Record<string, TagCategory>
  }

  async function getAvailableTags(): Promise<AvailableTagsResponse> {
    try {
      const headers = await authHeaders()
      return await $fetch<AvailableTagsResponse>(
        `${API_BASE}/tagging/tags/available`,
        {
          method: 'GET',
          headers,
        }
      )
    } catch (err: any) {
      throw new Error(err?.data || err?.message || 'Failed to fetch tags')
    }
  }

  // --- Get user's actual tags ---
  interface UserTagsResponse {
    categories: Record<string, string[]>
    total_unique_tags: number
  }

  async function getUserTags(tagType: 'document' | 'image' = 'document'): Promise<UserTagsResponse> {
    try {
      const headers = await authHeaders()
      return await $fetch<UserTagsResponse>(
        `${API_BASE}/tagging/tags/user-tags?tag_type=${tagType}`,
        {
          method: 'GET',
          headers,
        }
      )
    } catch (err: any) {
      throw new Error(err?.data || err?.message || 'Failed to fetch user tags')
    }
  }

  // --- Upload Video ---
  async function uploadVideo(file: File, groupId?: string): Promise<UploadResponse> {
    try {
      const headers = await authHeaders()
      const fd = new FormData()
      fd.append('file', file)
      if (groupId) fd.append('group_id', groupId)

      const response = await $fetch<UploadResponse>(`${API_BASE}/ingest/upload-video`, {
        method: 'POST',
        headers,
        body: fd,
      })

      return response
    } catch (err: any) {
      throw new Error(err?.data || err?.message || 'Video upload failed')
    }
  }

  // --- Query Video ---
  async function queryVideo(opts: VideoQueryOpts): Promise<QueryResponse> {
    try {
      const headers = {
        'Content-Type': 'application/json',
        ...(await authHeaders()),
      }

      return await $fetch<QueryResponse>(`${API_BASE}/ingest/query-video`, {
        method: 'POST',
        headers,
        body: {
          query_text: opts.query,
          route: opts.route,
          top_k: opts.top_k ?? 10,
          group_id: opts.group_id ?? undefined,
        },
      })
    } catch (err: any) {
      throw new Error(err?.data || err?.message || 'Video query failed')
    }
  }

  return {
    uploadFile,
    uploadVideo,
    getProcessingStatus,
    pollProcessingStatus,
    queryText,
    queryImage,
    queryVideo,
    deleteDoc,
    queryByTags,
    queryImagesByTags,
    getAvailableTags,
    getUserTags,
  }
}